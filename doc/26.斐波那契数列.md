# [斐波那契数列](https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof/)

## 1. 题目描述

> 写一个函数，输入 n ，求斐波那契（Fibonacci）数列的第 n 项（即 F(N)）。斐波那契数列的定义如下：
>
> F(0) = 0,   F(1) = 1
> F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
> 斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。
>
> 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。
>
> 示例 1：
>
> 输入：n = 2
> 输出：1
> 示例 2：
>
> 输入：n = 5
> 输出：5
>
>
> 提示：
>
> 0 <= n <= 100

## 2. 注意点&个人思路

可以配合24题的青蛙跳台阶。主要是初始条件不一样。

斐波那契数列 [0] 0 [1] 1 从2开始 青蛙跳台阶 [0] 1 [1] 1 从2开始

## 3. 基础知识补充

```java
// 按照指定数值填充数组
public static void main(String[] args) throws Exception {
        int data[] = new int[20];
        Arrays.fill(data, -1);
        System.out.print(data[0]); // -1
        System.out.print(data[1]); // -1
        System.out.print(data[2]); // -1
}
```

## 4. 题解

### 思路1  递归法 错误做法 因为超时

其实原理很简单 就是 一个 *f(n) = f(n - 1) + f(n - 2)*。

```java
class Solution {
    public int numWays(int n) {
        if (n == 0 || n == 1) {
        	return n;
        }
        return (numWays(n - 1) + numWays(n - 2)) % 1_000_000_007;
    }
}
```

### 思路2 动态规划

原理： 以斐波那契数列性质 *f(n+1)=f(n)+f(n−1)* 为转移方程。
从计算效率、空间复杂度上看，动态规划是本题的最佳解法。

```java
class Solution {
    public int fib(int n){
		if (n == 0) return 0;
		int[] dp = new int[n + 1];
		dp[1] = 1;
		for(int i = 2; i < n + 1; i++){
			dp[i] = (dp[i - 2] + dp[i -1]) % 1_000_000_007;
		}
		return dp[n];
	}
}
```

**省内存版本**

```java
class Solution {
    public int fib(int n){
		int cur = 0, next = 1, temp;
        for(int i = 0; i < n; i++){
            temp = (cur + next) % 1_000_000_007;
            cur = next;
            next = temp;
        }
        return cur;
	}
}
```

## 总结

本质就是斐波那契数列。

做这种题大概的想法。

- 需要找到方程式
- 需要自己先有前几个到底是什么写一下。比如斐波那契数列[0、1、1、2、3、5、8、13、21、34]

