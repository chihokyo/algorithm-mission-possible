# 二进制中1的个数

## 1. 题目描述

> 请实现一个函数，输入一个整数，输出该数二进制表示中 1 的个数。例如，把 9 表示成二进制是 1001，有 2 位是 1。因此，如果输入 9，则该函数输出 2。
>
> 示例 1：
>
> 输入：00000000000000000000000000001011
> 输出：3
> 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。
> 示例 2：
>
> 输入：00000000000000000000000010000000
> 输出：1
> 解释：输入的二进制串 00000000000000000000000010000000 中，共有一位为 '1'。
> 示例 3：
>
> 输入：11111111111111111111111111111101
> 输出：31
> 解释：输入的二进制串 11111111111111111111111111111101 中，共有 31 位为 '1'。
>

## 2. 注意点&个人思路

二进制，位运算。因为不常用拿到这个题是懵逼的。

## 3. 基础知识补充

### 二进制

python里面 **数字 → 二进制方法**

```python
>>> bin(8)
'0b1000'
>>> print(0b1011)
11
>>> bin(0b00000000000000000000000000001011)
'0b1011'
```

### 位运算

```python
"""
>>  右移
<<  左移
|   位或 
&   位与
^   位异或
~   非
"""
==============================
>>> 0b11
3
>>> 0b11 >> 2
0
>>> bin(0)  
'0b0' # 0b11 右移动2个就没了
>>> 0b11 << 2 
12
>>> bin(12)
'0b1100' #0b11 左移补0 成ob1100
==============================
# 位或 or 只要是1都是1
>>> 0b1111 | 0b0011
15
>>> bin(15)
'0b1111'
==============================
# 位与 and 只要有1个0，就是0。必须都是1才为1
# 可以用于获取数字，用全部都是11111进行获取
>>> 0b1111 & 0b0011
3
>>> bin(3)
'0b11'
==============================
# 位异或 必须不相同才为1
# 用于 位反转
>>> 0b1111 ^ 0b0011
12
>>> bin(12)
'0b1100'
```



## 4. 题解

### 思路1 位运算& + 移位

-  设置res用来计数
- 利用位运算测试是否为1
- 右移进行1个个判断（右移直接掉补0，左移要判断正反）
- 返回结果

这里有一个需要注意的，n为0的问题。右移到最后n就是0。循环也会跳出。因为`bool(0) #False`。

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
        # 设置res0 进行与运算。
        # 判断最右边是否为1
        # 等于1 res就加1次 返回到后面就是次数
        res = 0
        # 只要n不为0
        while n:
            # n & 1 的结果要么是0，要么是1
            # 为什么用1 原因如下
            # 10111100
            # 00000001
            # ---&----
            # 00000000
            res += n & 1
            # 判断1次右移一次，直到没有n
            n >>= 1
        return res
```



### 思路2 巧用 n \& (n - 1)

抄袭大佬的方法

这样n和n-1进行与运算，最终n都会变成0。

![Picture10.png](https://pic.leetcode-cn.com/9bc8ab7ba242888d5291770d35ef749ae76ee2f1a51d31d729324755fc4b1b1c-Picture10.png)

利用n和n-1的区别就是 最后1位的010101这样变化进行取得最后1位，然后进行计算。

```python
class Solution:
    def hammingWeight(self, n: int) -> int:
      res = 0
      # 只要n不为0 bool(0)是False
      while n:
        # 先+1 因为是这时候n肯定不是0，说明里面还有1
        res += 1
        # 再次进行和-1的与预算。
        n &= (n-1)
      return res
```



### 思路3 一些Python骚操作

```python
"""
>>> a = bin(0b00001011)
>>> a.count('1')
注意这里的count(str)
数字没count()方法，就字符串有。所以里面要写的就是字符串count('1')
"""
class Solution:
    def hammingWeight(self, n: int) -> int:
        return bin(n).count('1')
"""
bin(n)[2:] 这地方表明了bin(n)返回的实际上是一个字符串
字符串转换成list，然后使用map()把所有的list里面的字符串转换成int，然后进行sum()计算
bin()->切片字符串->list()转换成列表->map(int,)转换成int->sum()计算
"""
class Solution:
    def hammingWeight(self, n: int) -> int:
        return sum(map(int, list(bin(n)[2:])))
```

## 总结

关于位运算的各种操作 + 二进制的转换。

还有部分Python函数的基本使用方法，数据类型等等有了一个认识。题目本身看起来不难，但是要用很多方法来做的话还是需要很扎实的基础。