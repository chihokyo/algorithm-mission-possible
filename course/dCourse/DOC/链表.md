# 链表

也是属于线性结构。

## 为什么要使用链表？

因为数组的话，需要一块连续的内存空间。

![image-20211108111907521](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108111908.png)

这样堆内存的对象数据，存储在不同的地方。如果数组的大小，比较小还好，如果很大的话，没有足够的内存空间。明明

就会造成很多冗余。

![image-20211108135212483](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108135213.png)

于是就设计出来了一种合理的充分利用**非连续的内存空间**的数据结构。

如何进行访问呢。于是就有了链表。

![image-20211108140917902](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108140919.png)

链表和数组比，不需要连续的内存空间。但是访问的时候需要地址。

比如下面这样。

![image-20211108141050103](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108141051.png)

## 链表PK数组

链表是非连续的内存空间。数组需要是连续的。

但是2者都是线性的数据结构。

![image-20211108141242129](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108141243.png)

## 链表实现

需要使用节点！

- 存储节点元素值
- 记录当前节点的下一个节点，Java的引用。

```java
class Node {
    E e;
	Node next;
}
```

就是这样

其中有2个特殊的

- 头节点 记录位置
- 尾节点 表示最后一个

![image-20211108141520927](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108141522.png)

代码实现

- 注意这里的内部类

```java
public class LinkedList<E> {

    // 1.内部类 表示1个节点
    private class Node {
        E e;
        Node next;

        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }

        public Node(E e) {
            this(e, null);
        }

        public Node() {
            this(null, null);
        }

        @Override
        public String toString() {
            return e.toString();
        }
    }

    // 2. 初始化
    private Node head; // 头节点
    private int size; // 长度

    // 3. 构造函数
    public LinkedList() {
        head = null;
        size = 0;
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public int getSize() {
        return size;
    }
}
```

上面只是简单实现了一个链表，但是没有增删改查。

## 链表查询指定的元素

### 逻辑实现

关于链表的索引。数组可以简单的通过选址，直接定位。

但是链表并不都是连着的，目前知道的只有头节点的那个地址，所以要1个个遍历。

![image-20211108143204298](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108143205.png)

![image-20211108143234075](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108143234.png)

上面是逻辑。

关于链表的size，从头上可以看出来。

![image-20211108143432493](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108143433.png)

### 代码实现

```java
/**
 * 查询指定index的值
 *
 * @param index 索引
 * @return E 返回值
 */
public E get(int index) {
    if (index < 0 || index >= size)
        throw new IllegalArgumentException("get Failed, index is illegal");
    Node cur = head;
    for (int i = 0; i < index; i++) {
        cur = cur.next;
    }
    return cur.e;
}
// 获取第一个值
public E getFirst() {
    return get(0);
}
// 获取最后一个值
public E getLast() {
    return get(size - 1);
}
```

## 链表修改指定的元素

### 逻辑实现

比如下面修改指定节点的值

- 找到指定节点的索引
- 修改值

![image-20211108144101688](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108144103.png)

### 代码实现

```java
/**
 * 修改指定索引的元素
 *
 * @param index 索引
 * @param e     设置的新值
 */
public void set(int index, E e) {
    if (index < 0 || index >= size)
        throw new IllegalArgumentException("get Failed, index is illegal");
    Node cur = head;
    for (int i = 0; i < index; i++) {
        cur = cur.next;
    }
    cur.e = e;
}
```

## 链表添加指定的元素

### 逻辑实现（头节点）

由于链表的数据结构特殊，所以需要考虑是在头节点添加，还是中间节点添加。

如果在head头节点添加的话。

- 创建节点 （这个时候next指向null）
- 然后把next原本指向null，然后指向head
- 这个时候移动头结点

![Nov-08-2021 14-46-29](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108144921.gif)

然后移动头结点

![Nov-08-2021 14-48-17](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108144933.gif)

### 代码实现（头节点）

```java
/**
 * 在链表头增加节点
 *
 * @param e 新增节点的数据
 */
public void addFirst(E e) {
    // 基本
    Node newNode = new Node(e);
    newNode.next = head;
    head = newNode;
    
    // 优化1
    // Node newNode = new Node(e, head); // 直接创建一个连接到链表头的节点
    // head = newNode;// 移动链表头

    // 优化2
    head = new Node(e, head); // 新建之后直接给了链表头
    size++;
}
```

这里的2个优化要想看懂还是很难的哈！！！

### 逻辑实现（中间）

四步走。

- 新建节点
- 找到插入前的位置
- node.next = prev.next
- prev.next = node

![Nov-08-2021 15-14-40](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108151914.gif)

![image-20211108151700923](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108151702.png)

请问，这个最后2步可以交换吗。

答案是不可以的！！

![image-20211108151835958](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108151836.png)

### 代码实现（中间）

```java
/**
 * 在任意位置添加元素
 *
 * @param index 索引
 * @param e     新增节点的数据
 */
public void add(int index, E e) {
    if (index < 0 || index >= size)
        throw new IllegalArgumentException("add Failed, index is illegal");

    if (index == 0) {
        addFirst(e);
    } else {
        // 1. 暂存头节点用于下面向前走
        Node prev = head;
        // 2.初始化新元素
        Node newNode = new Node(e);
        // 3.找到前一个节点
        for (int i = 0; i < index - 1; i++) {
            prev = prev.next;
        }
        // 4.找到之后 先把后面的起来，再把前面的连起来！
        newNode.next = prev.next;
        prev.next = newNode;
        size++;

        // 优化1 无需初始化
        // Node newNode =  newNode(e, prev.next);
        // prev.next = newNode;

        // 优化2  无需初始化
        // prev.next = newNode(e, prev.next);

    }
```

## 链表删除元素

### 逻辑实现（删除头节点）

直接删除，head指向null不就行了？

![image-20211108153044248](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108153045.png)

那么移动在删除呢?

![image-20211108153207218](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108153208.png)

所以最后可以暂存一下。然后在断掉。

![image-20211108154011650](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108154012.png)

最后也就实现了

### 代码实现（删除头节点）

```java
/**
 * 删除链表头节点
 *
 * @return 返回链表头
 */
public E removeFirst() {
    // 如果为空 就直接null
    if (head == null) return null;

    // 1.暂存链表头
    Node delNode = head;
    // 2.移动
    head = head.next;
    // 3.删除暂存的链表头
    delNode.next = null;

    return delNode.e;
}
```

### 逻辑实现（删除中间节点）

- 先找到待删除的前一个节点
- 然后存储删除节点
- 然后断开前后连接

![Nov-08-2021 15-47-23](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108154740.gif)

在上面指向的同时，也就断开了1条。

接下来断开第2条

![Nov-08-2021 15-48-58](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108154910.gif)

### 代码实现（删除中间节点）

```java
/**
 * 删除链表任意位置的节点
 *
 * @param index 索引位置
 * @return 删除掉的节点值
 */
public E remove(int index) {
    if (index < 0 || index >= size)
        throw new IllegalArgumentException("remove Failed, index is illegal");
    if (index == 0) return removeFirst();
    // 移动用暂存
    Node prev = head;
    for (int i = 0; i < index - 1; i++) {
        prev = prev.next;
    }
    // 1. 暂存
    Node delNode = prev.next;
    // 2. 掐断第一条线，直接略过本身指向下一个
    prev.next = delNode.next;
    // 3. 掐断第二条线 暂存指向null 彻底断开
    delNode.next = null;
    size--;
    return delNode.e;
}
```

## 关于虚拟节点

为什么需要虚拟节点？

每次头节点都需要特殊处理，这样很不优雅。不一样的原因，因为**头节点没有prev**，其他中间的有。所以处理起来不一样。

像下面这样设置，就可以解决了。

![image-20211108160316107](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211108160317.png)

