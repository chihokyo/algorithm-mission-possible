# 数组 Array

数组是线性数据结构，使用数组存储的数据会排成像一条线一样。

数组本身没有什么方法，都是Object类给的方法，只有1个属性。就是*length*

![image-20211107000116578](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107000123.png)

数组是用一组连续的内存空间，来存储一组具有相同类型的数据。

这里的1个int是6个4个byte，也就是32个bit。

![image-20211107000324144](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107000325.png)

如果想要修改的话，

算出来内存地址之后，然后直接操作。

![image-20211107000453435](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107000454.png)

所以说数组的**随机读写性能**会很好

但是，如果随机 **新增 + 删除** 呢？

比如下面插入一个元素。

![image-20211107000823388](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107000824.png)

- 原因1 没有空间，以为数组本身空间固定
- 原因2 内存空间的连续性，不能打破

## 静态数组

代码实现如下。

空间复杂度 O(n)

时间复杂度 因为2个循环，加法计算，最后的2个O(n)加起来。就是O(n)

```java
/**
 * 将指定的元素插入到新的指定数组的指定位置上
 *
 * @param src     需要插入元素的数组
 * @param index   插入数组的元素
 * @param element 需要插入的元素值
 * @return 返回最新的数组
 */
public static int[] insertElement(int[] src, int index, int element) {
    int length = src.length;
    // 1 初始化新数组
    int[] dest = new int[length + 1];

    // 2 把index前面的拷贝到新数组里
    for (int i = 0; i < index; i++) {
        dest[i] = src[i];
    }

    // if (index >= 0) System.arraycopy(src, 0, dest, 0, index);

    // 3 插入操作
    dest[index] = element;

    // 4 把index后面的拷贝到新数组里

    for (int i = index; i < length; i++) {
        dest[i + 1] = src[i];
    }
    // System.arraycopy(src, index, dest, index + 1, dest.length - index);

    return dest;

}
```

删除元素

![image-20211107003352965](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107003353.png)

代码实现

时间复杂度和空间复杂度都是和修改一样，结果是O(n)

```java
/**
 * 删除指定位置的元素
 *
 * @param src   需要删除的元素
 * @param index 指定位置
 * @return 新的数组
 */
public static int[] removeElement(int[] src, int index) {
    int[] dest = new int[src.length - 1];
    for (int i = 0; i < index; i++) {
        dest[i] = src[i];
    }
    // if (index >= 0) System.arraycopy(src, 0, dest, 0, index);
    // 这里就忽略了index
    for (int i = index; i < src.length - 1; i++) {
        // 这里就忽略了index
        dest[i] = src[i + 1];
    }
    // if (src.length - 1 - index >= 0) System.arraycopy(src, index + 1, dest, index, src.length - 1 - index);

    return dest;
}
```

## 二次封装

上面实现的一些方法其实有一个问题，那就是

- 重复代码太多。增加通用性问题 封装一下。

- 修改不严谨的验证方式

![image-20211107004558568](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107004559.png)

所以接下来继续封装一下。

首先就需要一个数组，因为这个必须要有一个数组来承载所有的信息。

![image-20211107005101555](https://raw.githubusercontent.com/chihokyo/image_host/develop/20211107005102.png)

