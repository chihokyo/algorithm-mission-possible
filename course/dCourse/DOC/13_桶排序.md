# 桶排序

什么是桶排序呢？

桶排序（Bucket Sort）是一种分布式排序算法，它将一个数组分到有限数量的桶里。每个桶分别排序，再把每个桶里的值依次取出，放回到原数组，由于已经在各个桶里进行了排序，所以输出的结果也是排序好的。以下是桶排序的基本步骤：

1. 确定数组的**最大值和最小值**，以及**桶的数量**。
2. 创建等量的桶，每个桶的区间根据最大值和最小值的差值以及桶的数量来计算。比如，假设最小值为 min，最大值为 max，桶的数量为 n，则每个桶的区间为：**(max-min)/n**。
3. 将每个元素分配到对应的桶中。这个步骤可以通过计算**元素与最小值的差值然后除以每个桶的区间**来完成。
4. 对每个桶进行排序。这个步骤可以使用其他排序算法或者递归使用桶排序。
5. 遍历每个桶，将桶中的元素依次放回到原数组。

桶排序的时间复杂度为**O(n+k)**，其中 n 是输入数组的长度，k 是桶的数量。如果所有元素均匀地分配到每个桶，那么这个算法可以达到线性的时间复杂度。桶排序不是比较排序，它是整数排序。

桶排序特别适用于以下场景：

- 输入是均匀分布的：桶排序的性能依赖于输入的数据分布。如果输入的数据可以均匀、独立地分布在每个桶，那么桶排序的性能最好。如果输入是随机分布的，那么桶排序也有不错的效果。
- 数据量较大，且有明确的范围：当数据量很大，且最大值和最小值之间的范围相对较小，我们可以创建足够多的桶，这样可以保证数据均匀分布在各个桶中，提高排序效率。
- 需要稳定的排序：如果需要稳定的排序算法（即相等的元素在排序后保持原来的相对顺序），桶排序是一个好的选择，因为它是**稳定**的。

需要注意的是，桶排序需要大量的内存空间，因此当数据量非常大或者可用内存非常小的时候，使用桶排序可能不太适合。

![image-20230614135834517](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230614135834517.png)

## 具体实现

那么具体怎么实现呢？首先要有几个难点。

**需要几个桶？**

直接说结论 **最大值 / 10 +1**。为什么要+1? 比如你是 56，实际上是需要 6 个桶的。要保证所有元素都有桶。

```java
0-9 10-19 20-29 30-39 40-49 50-59 // 6个桶
```

> ⚠️ 此处插播一下，很多算法用的桶的个数计算方法也有可能是 **（最大值 - 最小值）/ 长度 +1 ** 这种算法更常见
>
> 如果按照这个方法的话，那么计算值该放进哪个桶的计算公式就是 **int bucketIndex = (num - minVal) / arr.length;** 为什么呢？计算元素值与最小值的差值与桶的范围的比例。这种计算方式可以保证元素值越小的元素被分配到索引越小的桶中，元素值越大的元素被分配到索引越大的桶中。

虽然想保证每个桶都均匀下来，但是实际情况就是每个桶可能大小都不一样。

**如何计算数值放到哪个桶？**

直接结论，**index = 元素 / 10** 。比如 36，那么就是 36/10 放到索引为 3。5 的话就是 0，11 就是 1,23 就是 2，20 就是 2。这个只是一种求桶 index 的方式。

可是这个不是唯一的答案，可以看到 ChatGPT 给的解释。

```
【桶排序里是如何计算有几个桶 如何计算元素该放进哪个桶的 请用例子具体说明】

确定桶的数量和确定元素放入哪个桶，都是根据数据的分布来决定的。假设我们的数据是0到100的整数，并且均匀分布，我们想要进行桶排序。
确定桶的数量：
这通常是基于经验或数据分布来决定的。例如，如果我们的数据是0到100的整数，我们可以设置10个桶，每个桶的范围是10（例如，第一个桶存放0-9，第二个桶存放10-19，以此类推）。这样，每个桶的范围就是 (max - min) / bucket_count，其中 max 和 min 是数据的最大值和最小值，bucket_count 是桶的数量。
确定元素放入哪个桶：
这是根据元素的值和桶的范围来决定的。首先，我们需要计算元素与最小值的差值，然后除以桶的范围。在我们的例子中，如果一个元素的值是73，那么它与最小值（也就是0）的差值是73，除以桶的范围（也就是10）得到7.3。然后我们向下取整，得到7。所以这个元素应该放入第8个桶（因为桶的索引从0开始）。
使用这种方法，我们可以保证每个元素都会被放入正确的桶中。然后我们对每个桶内的元素进行排序，最后依次取出每个桶中的元素，就得到了排序后的数组。
需要注意的是，上述的方法是一种常用的方法，但并非唯一的方法。确定桶的数量和元素放入哪个桶的具体策略，可以根据数据的特性和需求进行调整。


【那你在举另一个确定数量和放入哪个桶的具体策略】

确定桶的数量和元素放入哪个桶的策略可以根据具体的应用场景和数据特性进行调整。下面是另一个例子。
假设我们要对一组来自于一天内（24小时）的时间戳进行排序，这些时间戳是以秒为单位的，也就是说范围在0到86400之间。
确定桶的数量：
由于时间戳的特性，我们知道数据将会均匀地分布在这个范围内，所以我们可以按照小时来划分桶。因为一天有24小时，所以我们可以创建24个桶。
确定元素放入哪个桶：
每个桶代表一小时的时间，每小时有3600秒。我们可以通过将时间戳除以3600并向下取整，得到该时间戳应该被放入哪个桶。例如，如果一个时间戳是4500秒，那么 4500 / 3600 的结果是1.25，向下取整后得到1，所以这个时间戳应该放入第二个桶（桶的索引从0开始）。
在这个策略中，我们根据数据的特性（即一天内的时间戳）和我们的需求（即按小时进行排序）来确定桶的数量和元素放入哪个桶的策略。这种策略使得我们可以高效地对时间戳进行排序。同时，由于每个桶内的时间戳都在一个小时的范围内，我们也可以方便地进行进一步的操作，例如按分钟或秒进行排序。
```

**桶排序是通过二维数组来存储的**。这个可以看 ChatGPT 给的答案。

![image-20230614164302300](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230614164302300.png)

那么接下来直接写代码

```java
/**
     * 思路其实很清晰 只要按照大方向走
     *
     * @param array
     */
    public static void bucketsort(int[] array) {
        // 1. 先找到最大值和最小值
        int maxValue = array[0];
        int minValue = array[0];
        for (int i = 0; i < array.length; i++) {
            maxValue = Math.max(maxValue, array[i]);
            minValue = Math.min(minValue, array[i]);
        }
        // 2.计算桶的数量 & 初始化桶
        // 这个求数量理解起来也很难
        int bucketCount = (maxValue - minValue) / array.length + 1;
        List<List<Integer>> buckets = new ArrayList<>(bucketCount);
        for (int i = 0; i < bucketCount; i++) {
            buckets.add(new ArrayList<>());
        }

        // 3.分配每个元素到桶里
        for (int num : array) {
            // 求出放在那个index 这个算法死记硬背吧 这个理解起来难
            int bucketIndex = (num - minValue) / array.length;
            buckets.get(bucketIndex).add(num);
        }
        // 4. 对每个桶进行排序
        int cur = 0;
        // 先取出来每个桶
        for (List<Integer> bucket :
                buckets) {
            // 排序每个桶
            Collections.sort(bucket);
            for (int num : bucket) {
                // 最后输出到原数组
                array[cur++] = num;
            }
        }
    }
```

> 上面那段代码的难点在于哪里呢？
>
> - 计算桶的数量 `int bucketCount = (maxValue - minValue) / array.length + 1;`
> - 计算元素该放在哪个桶 `int bucketIndex = (num - minValue) / array.length;`
> - 取出数据的时候别忘记要遍历 2 层数组

## 时间复杂度&特点

![image-20230614142019849](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230614142019849.png)

特点的话其实总结

![image-20230614162154005](https://raw.githubusercontent.com/chihokyo/image_host/develop/image-20230614162154005.png)

千言万语，桶排序对于**数据本身的要求很高**。
